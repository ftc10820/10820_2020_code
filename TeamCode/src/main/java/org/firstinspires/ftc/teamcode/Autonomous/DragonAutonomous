package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DistanceSensor;
import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;
import java.lang.annotation.Target;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import java.util.List;
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaCurrentGame;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
import org.firstinspires.ftc.robotcore.external.tfod.Recognition;
import org.firstinspires.ftc.robotcore.external.tfod.TfodCurrentGame;

// For the IMU
import com.qualcomm.hardware.bosch.BNO055IMU;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
import org.firstinspires.ftc.robotcore.external.navigation.Position;
import org.firstinspires.ftc.robotcore.external.navigation.Velocity;


@Autonomous
public class VLTestAutonomous extends LinearOpMode {

  private VuforiaCurrentGame vuforiaUltimateGoal;
  private TfodCurrentGame tfodUltimateGoal;
  
  // The orientation/position is based on a view of a person looking at the 
  // front of the robot. The front of the robot is the side of the robot where
  // the rings are shot from. The back is where the intake mechanism is 
  private DcMotorEx driveBL; // Back Left drive motor 
  private DcMotorEx driveFL; // Front Left drive motor 
  private DcMotorEx driveBR; // Back Right drive motor 
  private DcMotorEx driveFR; // Front Right drive motor
  
  private DcMotor shooter1;
  private DcMotor shooter2;
  private DcMotor intake;
  private DcMotor wafflemotor;


  private CRServo intakemotor;
  private Servo waffle1;
  private Servo waffle2;

  private ColorSensor launchLine;
  private DistanceSensor distanceLeft;
  private DistanceSensor distanceFront;
  private DistanceSensor distanceRight;

  Recognition recognition;
  private int AZONE = 1; // these are const values
  private int BZONE = 2;
  private int CZONE = 3;
  private int final_zone = AZONE; // using a default so it doesnt mess things up

  // For the IMU 
  BNO055IMU               imu;
  Orientation             lastAngles = new Orientation();
  double                  globalAngle, power = .30, correction;

  /**
   * This function is executed when this Op Mode is selected from the Driver Station.
   */
  @Override
  public void runOpMode() {

    initializeRobot();

    List<Recognition> recognitions;
    int index = 0; // VL: changing index to int from double

    vuforiaUltimateGoal = new VuforiaCurrentGame();
    tfodUltimateGoal = new TfodCurrentGame();

    // Sample TFOD Op Mode
    // Initialize Vuforia.
    vuforiaUltimateGoal.initialize(
        "", // vuforiaLicenseKey
        hardwareMap.get(WebcamName.class, "Webcam 1"), // cameraName
        "", // webcamCalibrationFilename
        false, // useExtendedTracking
        false, // enableCameraMonitoring
        VuforiaLocalizer.Parameters.CameraMonitorFeedback.AXES, // cameraMonitorFeedback
        0, // dx
        0, // dy
        0, // dz
        0, // xAngle
        0, // yAngle
        0, // zAngle
        true); // useCompetitionFieldTargetLocations

    // Set min confidence threshold to 0.7; VL: maybe higher confidence??
    tfodUltimateGoal.initialize(vuforiaUltimateGoal, 0.7F, true, true);

    // Initialize TFOD before waitForStart.
    // Init TFOD here so the object detection labels are visible
    // in the Camera Stream preview window on the Driver Station.
    tfodUltimateGoal.activate();

    // Enable following block to zoom in on target.
    tfodUltimateGoal.setZoom(2.5, 16 / 9);
    
/*
    driveBL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    
    driveBL.setVelocity(250.0); 
    sleep(5000) ;
    telemetry.addData("driveBL", driveBL.getVelocity());
    driveBL.setPower(0.0); 
    sleep(3000) ;
    
    driveFL.setVelocity(250.0); 
    sleep(5000) ;
    telemetry.addData("driveFL", driveFL.getVelocity());
    driveFL.setPower(0.0); 
    sleep(3000) ;

    driveBR.setVelocity(250.0); 
    sleep(5000) ;
    telemetry.addData("driveBR", driveBR.getVelocity());
    driveBR.setPower(0.0); 
    sleep(3000) ;

    driveFR.setVelocity(250.0);bl 
    sleep(5000) ;
    telemetry.addData("driveFR", driveFR.getVelocity());
    driveFR.setPower(0.0); 
    sleep(3000) ;
    */

    /*
    driveBL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    
    driveBL.setPower(0.5); 
    sleep(5000) ;
    telemetry.addData("driveBL", driveBL.getVelocity());
    driveBL.setPower(0.0); 
    sleep(3000) ;
    
    driveFL.setPower(0.5); 
    sleep(5000) ;
    telemetry.addData("driveFL", driveFL.getVelocity());
    driveFL.setPower(0.0); 
    sleep(3000) ;

    driveBR.setPower(0.5); 
    sleep(5000) ;
    telemetry.addData("driveBR", driveBR.getVelocity());
    driveBR.setPower(0.0); 
    sleep(3000) ;

    driveFR.setPower(0.5); 
    sleep(5000) ;
    telemetry.addData("driveFR", driveFR.getVelocity());
    driveFR.setPower(0.0); 
    sleep(3000) ;
    
    */
    /*  
    strafeLeftPower(0.5) ;
    sleep(5000);
    stopAllWheelsPower();
    sleep(1000);
    moveBackwardPower(0.25) ;
    sleep (1000);
    stopAllWheelsPower();
    sleep(500);
    getIMUAngles() ; // the angles get into lastAngles 
    displayOrientationValues(lastAngles, "End") ;
    */
    
    
    telemetry.addData(">", "Press Play to start");
    telemetry.update();

    // Wait for start command from Driver Station.

    waitForStart();

    if (opModeIsActive()) {
      
      // we may need to do a couple of tries to be really confident of the 
      // response from the video detection. 

      int nvideo_attempts = 3 ; // change this if required. You can change it to 1 as well
      int azone_successes = 0 ;
      float azone_confidence = 0.0F ;
      int bzone_successes = 0 ;
      float bzone_confidence = 0.0F ;
      int czone_successes = 0 ;
      float czone_confidence = 0.0F ;

      while (nvideo_attempts > 0) {
        nvideo_attempts-- ; // reduce count first so you dont forget later 
        
        // Put loop blocks here.
        // Get a list of recognitions from TFOD.
        recognitions = tfodUltimateGoal.getRecognitions();

        // If list is empty, inform the user. Otherwise, go
        // through list and display info for each recognition.
        if (recognitions.size() == 0) {
          azone_successes++ ; 
          azone_confidence += 0.9F ; // just giving it something nominal rather than 1.0 
          telemetry.addData("TFOD ", "No items detected.");
          telemetry.addData("Target Zone ", "A");
        } else {
          if (recognitions.size() > 1) {
            telemetry.addData("TFOD ", "More than 1 item detected");
          }
          
          index = 0;
          // Iterate through list and call a function to
          // display info for each recognized object.
          for (Recognition recognition_item : recognitions) {
            recognition = recognition_item;
            
            if (recognition.getLabel().equals("Single")) {
              telemetry.addData("Target Zone ", "B");
              bzone_successes++ ; 
              bzone_confidence += recognition.getConfidence() ;
            } else if (recognition.getLabel().equals("Quad")) {
              telemetry.addData("Target Zone ", "C");
              czone_successes++ ; 
              czone_confidence += recognition.getConfidence() ;
            } else {
              telemetry.addData("TFOD ", "Unknown label " + recognition.getLabel());
              telemetry.addData("Target Zone ", "Unknown");
            }
            // Display info.
            //displayInfo(index); Commenting this out because details are not required
            // Increment index.
            index = index + 1;
          } // end of recoginition list 
        } // end of else for recognition list empty
        telemetry.update() ; // make sure telemetry is updated 
        
        // the below is meant to carry out a small number of movements on 
        // the robot to check if the result from vuforia is different
        moveBackwardPower(0.5) ;
        sleep(200);
        stopAllWheelsPower();
        sleep(200);
        
      } // end of while number of tries 
      
      telemetry.addData("AZone ", azone_successes + " " + azone_confidence);
      telemetry.addData("BZone ", bzone_successes + " " + bzone_confidence);
      telemetry.addData("CZone ", czone_successes + " " + czone_confidence);
      
      // Now decide on the final zone 
      // This can be done in a number of ways 
      // simple way would be to use the accumulated confidence levels 
      if (azone_confidence > bzone_confidence) {
        if (azone_confidence > czone_confidence) {
          // A is the clear winner
          final_zone = AZONE ; 
          telemetry.addData("Final Zone", " A");
        } else {
          // C is the clear winner
          final_zone = CZONE ;
          telemetry.addData("Final Zone", " C");
        }
      } else {
        if (bzone_confidence > czone_confidence){
          // B is the clear winner 
          final_zone = BZONE ;
          telemetry.addData("Final Zone", " B");
        } else {
          // C is the winner
          final_zone = CZONE ;
          telemetry.addData("Final Zone", " C");
        }
      }
      telemetry.update();
      
      if (final_zone == AZONE) {
        targetZoneA();
      } else {
        if (final_zone == BZONE) {
          targetZoneB();
        } else {
          targetZoneC();
        }
      }
      
        /*
        drive1.setPower(-0.5);
        drive2.setPower(-0.5);
        drive3.setPower(-0.5);
        drive4.setPower(-0.5);
        sleep(100);
  
        drive1.setPower(0);
        drive2.setPower(0);
        drive3.setPower(0);
        drive4.setPower(0);
  
        shooter(0.75);
        sleep(2000);
  
        inclinedPlane(1);
        sleep(2000);
  
        noodles(1);
        sleep(10000);
  
        shooter(0);
        inclinedPlane(0);
        noodles(0);
  
        telemetry.addData("red:", launchLine.red());
        telemetry.addData("blue:", launchLine.blue());
        telemetry.addData("green:", launchLine.green());
        telemetry.addData("alpha:", launchLine.alpha());
        telemetry.update();
        */
        
    } // end of if Opmode is active 
    
    // Deactivate TFOD.
    tfodUltimateGoal.deactivate();

    vuforiaUltimateGoal.close();
    tfodUltimateGoal.close();
    
  } // end of runOpmode


  /**
   * Display info (using telemetry) for a recognized object.
   */
  private void displayInfo(int i) {
    // Display label info.
    // Display the label and index number for the recognition.
    telemetry.addData("label " + i, recognition.getLabel());
    // Display upper corner info.
    // Display the location of the top left corner
    // of the detection boundary for the recognition
    telemetry.addData("Left, Top " + i, recognition.getLeft() + ", " + recognition.getTop());
    // Display lower corner info.
    // Display the location of the bottom right corner
    // of the detection boundary for the recognition
    telemetry.addData("Right, Bottom " + i, recognition.getRight() + ", " + recognition.getBottom());

    if (recognition.getLabel().equals("Single")) {

      telemetry.addData("Target Zone ", "B");

    } else if (recognition.getLabel().equals("Quad")) {

      telemetry.addData("Target Zone ", "C");

    } else {

      telemetry.addData("Target Zone ", "A");

    }
  }


  private void initializeRobot() {

      //hardware maps of motors
      driveBL = hardwareMap.get(DcMotorEx.class, "drive1");
      driveFL = hardwareMap.get(DcMotorEx.class, "drive2");
      driveFR = hardwareMap.get(DcMotorEx.class, "drive3");
      driveBR = hardwareMap.get(DcMotorEx.class, "drive4");
      
      intake = hardwareMap.dcMotor.get("intake");
      shooter1 = hardwareMap.dcMotor.get("shooter1");
      shooter2 = hardwareMap.dcMotor.get("shooter2");
      wafflemotor = hardwareMap.dcMotor.get("wafflemotor");
      intakemotor = hardwareMap.get(CRServo.class, "intakemotor");
      launchLine = hardwareMap.get(ColorSensor.class, "color");
      distanceLeft = hardwareMap.get(DistanceSensor.class, "distanceLeft");
      distanceFront = hardwareMap.get(DistanceSensor.class, "distanceFront" );
      distanceRight = hardwareMap.get(DistanceSensor.class, "distanceRight" );

      //hardware maps of servos

      waffle1 = hardwareMap.servo.get("waffle1");
      waffle2 = hardwareMap.servo.get("waffle2");

      //directions
      driveBL.setDirection(DcMotor.Direction.REVERSE);
      driveFL.setDirection(DcMotor.Direction.REVERSE);
      driveBR.setDirection(DcMotor.Direction.FORWARD);
      driveFR.setDirection(DcMotor.Direction.FORWARD);
      intake.setDirection(DcMotor.Direction.FORWARD);
      shooter1.setDirection(DcMotor.Direction.FORWARD);
      shooter2.setDirection(DcMotor.Direction.REVERSE);
      wafflemotor.setDirection(DcMotor.Direction.FORWARD);
      intakemotor.setDirection(CRServo.Direction.FORWARD);

      //zero power behavior
      driveBL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      driveFL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      driveBR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      driveFR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

      // set the mode of operation; assumes that the encoder wires are connected
      driveBL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      driveFL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      driveBR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      driveFR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

      //initializeIMU();

      telemetry.addData("Status", "Initialized");
      telemetry.update();

  }
  
  private void initializeIMU() {
    BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();

    parameters.mode                = BNO055IMU.SensorMode.IMU;
    parameters.angleUnit           = BNO055IMU.AngleUnit.DEGREES;
    parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;
    parameters.loggingEnabled      = false;    

    // get and initialize the IMU 
    // The imu is assumed to be on I2C port 
    // and configured to be a sensor of type "AdaFruit IMU" and named "imu"
    imu = hardwareMap.get(BNO055IMU.class, "imu");

    imu.initialize(parameters);

    telemetry.addData("Mode", "IMU calibrating...");
    telemetry.update();

    // make sure the imu gyro is calibrated before continuing.
    while (!isStopRequested() && !imu.isGyroCalibrated())
    {
      sleep(50);
      idle();
    }

    telemetry.addData("imu calib status", imu.getCalibrationStatus().toString());
    telemetry.update( );
  }
  
  private void getIMUAngles() {
    lastAngles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.XYZ, AngleUnit.DEGREES);
  }
  
  private void displayOrientationValues(Orientation orient, String name) {
    telemetry.addData(name, "X: " + orient.firstAngle + ", Y: " + orient.secondAngle + ", Z: " + orient.thirdAngle);
  }
  
  private void moveForwardVelocity(double nticks) {
    driveBL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBL.setVelocity(nticks) ;
    driveFL.setVelocity(nticks) ;
    driveBR.setVelocity(nticks) ;
    driveFR.setVelocity(nticks) ;
  }


  private void moveBackwardPower(double power) {
    driveBL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBL.setPower(power * -1.0);
    driveFL.setPower(power * -1.0);
    driveBR.setPower(power * -1.0);
    driveFR.setPower(power * -1.0);
  }

  private void moveForwardPower(double power) {
    driveBL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBL.setPower(power);
    driveFL.setPower(power);
    driveBR.setPower(power);
    driveFR.setPower(power);
  }
  
  private void strafeRightPower(double power) {
    driveBL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBL.setPower(power * -1.0);
    driveFL.setPower(power);
    driveBR.setPower(power);
    driveFR.setPower(power * -1.0);
  }
  
  private void strafeLeftPower(double power) {
    driveBL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBL.setPower(power);
    driveFL.setPower(power * -1.0);
    driveBR.setPower(power * -1.0);
    driveFR.setPower(power);
  }

  // do we have to set the mode when switching off?  
  public boolean shouldStop() {
    return (distanceRight.getDistance(DistanceUnit.INCH) > 7);
  }
      
  private void stopAllWheelsPower() {
    driveBL.setPower(0.0);
    driveFL.setPower(0.0);
    driveBR.setPower(0.0);
    driveFR.setPower(0.0);
  }

  private void shooter(double power) {

      shooter1.setPower(power * -1.0);
      shooter2.setPower(power);

  }

  private void inclinedPlane(double power) {
      intake.setPower(power);
  }

  private void noodles(double power) {
      intakemotor.setPower(power);
  }

  private void targetZoneA() {
      
      strafeRightPower(0.5);
      sleep(1000);
      
      stopAllWheelsPower();
      
      sleep(150);
      
      driveFR.setPower(-1);
      driveBR.setPower(-1);
      driveBL.setPower(1);
      driveFL.setPower(1);
      sleep(400);
      
      stopAllWheelsPower();
      
      while (distanceRight.getDistance(DistanceUnit.INCH) > 7) {
      
        strafeRightPower(0.5);

      }
      
      stopAllWheelsPower();
      
      driveFR.setPower(-1);
      driveBR.setPower(-1);
      driveBL.setPower(1);
      driveFL.setPower(1);
      sleep(150);
      
      stopAllWheelsPower();
      
      while (launchLine.alpha() < 275) {
        
        moveBackwardPower(0.5);
        
      }
      
      stopAllWheelsPower();
      
      waffle1.setPosition(1);
      waffle2.setPosition(-1);
      sleep(1000);
      
      wafflemotor.setPower(1);
      sleep(1500);
      
      wafflemotor.setPower(0);
      
      waffle1.setPosition(-1);
      waffle2.setPosition(1);
      sleep(1000);
      
      waffle1.setPosition(0.5);
      waffle2.setPosition(0.5);
      
      
  }

  private void targetZoneB() {
      
      strafeRightPower(0.5);
      sleep(1000);
      
      stopAllWheelsPower();
      
      sleep(150);
      
      driveFR.setPower(-1);
      driveBR.setPower(-1);
      driveBL.setPower(1);
      driveFL.setPower(1);
      sleep(400);
      
      stopAllWheelsPower();
      
      while (distanceRight.getDistance(DistanceUnit.INCH) > 7) {
      
        strafeRightPower(0.5);

      }
      
      stopAllWheelsPower();
      
      driveFR.setPower(-1);
      driveBR.setPower(-1);
      driveBL.setPower(1);
      driveFL.setPower(1);
      sleep(150);
      
      stopAllWheelsPower();
      
      while (launchLine.alpha() < 275) {
        
        moveBackwardPower(0.5);
        
      }
      
      stopAllWheelsPower();
      
      driveBL.setPower(-1);
      driveFL.setPower(-1);
      sleep(1000);
      
      stopAllWheelsPower();
      
      waffle1.setPosition(1);
      waffle2.setPosition(-1);
      sleep(1000);
      
      wafflemotor.setPower(1);
      sleep(1500);
      
      wafflemotor.setPower(0);
      
      waffle1.setPosition(-1);
      waffle2.setPosition(1);
      sleep(1000);
      
      waffle1.setPosition(0.5);
      waffle2.setPosition(0.5);
      
  }

  private void targetZoneC() {
      
      strafeRightPower(0.5);
      sleep(1000);
      
      stopAllWheelsPower();
      
      sleep(150);
      
      driveFR.setPower(-1);
      driveBR.setPower(-1);
      driveBL.setPower(1);
      driveFL.setPower(1);
      sleep(400);
      
      stopAllWheelsPower();
      
      while (distanceRight.getDistance(DistanceUnit.INCH) > 7) {
      
        strafeRightPower(0.5);

      }
      
      stopAllWheelsPower();
      
      driveFR.setPower(-1);
      driveBR.setPower(-1);
      driveBL.setPower(1);
      driveFL.setPower(1);
      sleep(200);
      
      stopAllWheelsPower();
      
      while (launchLine.alpha() < 275) {
        
        moveBackwardPower(0.5);
        
      }
      
      stopAllWheelsPower();
      
      moveBackwardPower(1.0);
      sleep(1850);
      
      stopAllWheelsPower();


      waffle1.setPosition(1);
      waffle2.setPosition(-1);
      sleep(1000);
      
      wafflemotor.setPower(1);
      sleep(1500);
      
      wafflemotor.setPower(0);
      
      waffle1.setPosition(-1);
      waffle2.setPosition(1);
      sleep(1000);
      
      waffle1.setPosition(0.5);
      waffle2.setPosition(0.5);
      
      
      
  }

  

} // end of VLTestAutonomous ClassNotFoundException


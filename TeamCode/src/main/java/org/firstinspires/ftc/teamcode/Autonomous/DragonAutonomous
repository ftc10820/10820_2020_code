package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.hardware.DistanceSensor;
import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;
import java.lang.annotation.Target;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import java.util.List;
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaCurrentGame;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
import org.firstinspires.ftc.robotcore.external.tfod.Recognition;
import org.firstinspires.ftc.robotcore.external.tfod.TfodCurrentGame;

// For the IMU
import com.qualcomm.hardware.bosch.BNO055IMU;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
import org.firstinspires.ftc.robotcore.external.navigation.Position;
import org.firstinspires.ftc.robotcore.external.navigation.Velocity;


@Autonomous
public class VLTestAutonomous extends LinearOpMode {

  // The orientation/position is based on a view of a person looking at
  // the robot from the top, shooter at front, intake at back
  // Right is where the wabble goal mechanism is 
  
  private DcMotorEx driveBR; // Back Right drive motor 
  private DcMotorEx driveFR; // Front Right drive motor 
  private DcMotorEx driveBL; // Back Left drive motor 
  private DcMotorEx driveFL; // Front Left drive motor

  // The two shooter motors   
  private DcMotor shooter1; // the slower core hex motor 
  private DcMotor shooter2; // the faster ultra planetary gear motor 
  
  // motors and servo for the conveyor belt and the noodles intake  
  private DcMotor conveyor;     // motor that runs the conveyor/inclined plane 
  private CRServo noodle;       // servo that runs the noodle intake mechanism
                                // Note that this is a servo and not a motor 
                                
  private Servo liftgate;       // servo for gate on the conveyor  
  
  
  // motor and servo for the wobble/waffle 
  private DcMotor wafflemotor;
  private Servo waffle1;
  private Servo waffle2;

  // the different sensors 
  private ColorSensor launchLineRight;
  private ColorSensor launchLineLeft;
  private DistanceSensor distanceLeft;
  private DistanceSensor distanceFront;
  private DistanceSensor distanceRight;
  private DistanceSensor distanceBack;

  // variables for Vuforia and the zone detection 
  private VuforiaCurrentGame vuforiaUltimateGoal;
  private TfodCurrentGame tfodUltimateGoal;
  private int AZONE = 1; // DONT CHANGE: these are const values
  private int BZONE = 2;
  private int CZONE = 3;
  private int final_zone = AZONE; // using a default so it doesnt mess things up

  // Variables for the IMU 
  BNO055IMU               imu;
  Orientation             lastAngles = new Orientation();
  double                  globalAngle, power = .30, correction;

  
  /**
   * This function is executed when this Op Mode is selected from the Driver Station.
   */
  @Override
  public void runOpMode() {

    initializeRobot(); // intialize the complete robot including camera, imu, etc.
    
    runTestCode() ;  // run any test code if required 
    sleep(1000) ;
    
    telemetry.addData(">", "Press Play to start");
    telemetry.update();

    // Wait for start command from Driver Station.
    waitForStart();

    if (opModeIsActive()) {

      detectZone() ; // determine number of rings and the zone for dropoff       
      
      // Irrespective of the zone, the first action is to get to the 
      // LaunchLine and align 
      // First just strafe and get closer to the perimeter wall 
      // and move backward aligning with the perimeter wall 
      // till the LaunchLine and then adjust 
      //moveBackwardAlongPerimeterToLaunchLineAndAlign(1.0) ;
      strafeRightPower(1.0) ;
      while(distanceRight.getDistance(DistanceUnit.INCH) > 15.0) {
      }
      driveFR.setPower(-1.0);
      driveBR.setPower(-1.0);
      driveFL.setPower(0.0);
      driveBL.setPower(0.0);
      sleep(200);
      stopAllWheelsPower();
      
      moveBackwardToLaunchLineAndAlign(0.75) ;

      if (final_zone == AZONE) {
        targetZoneA();
      } else {
        if (final_zone == BZONE) {
          targetZoneB(); 
        } else {
          targetZoneC();
        }
      }
      
      // strafe along the LaunchLine till we reach the shooting location
      // shoot all 3 power shots, moving for each one  
      // Ensure that the robot is back on the launchLine
        
    } // end of if Opmode is active 
    
    // Deactivate TFOD.
    tfodUltimateGoal.deactivate();

    vuforiaUltimateGoal.close();
    tfodUltimateGoal.close();
    
  } // end of runOpmode

  // A simple run test code function   
  private void runTestCode() {
    /* execute any test code if required 
     this is run before the start is pressed and helpful for debugging
     */
     
     shootPowerShots();
     
    //testRightColorSensorRun() ;
    //moveBackwardToLaunchLineAndAlign(0.75) ; 
    //testRightColorSensorRun() ;
    //moveBackwardToLaunchLineAndAlign(0.75) ;
    //moveBackwardAlongPerimeterToLaunchLineAndAlign(0.75) ;
    //sleep(10000) ; // sleep for sometime so you can see the values
    
    //rotate(180, 0.75) ;
    
     /*
     detectZone();
     sleep(5000) ;
     
     strafeRightPower(1.0) ;
     while (distanceRight.getDistance(DistanceUnit.INCH) > 15) {
       ;
     }
     stopAllWheelsPower();
     moveBackwardCorrection(1.0);
     */
    //rotate(180, 0.5);
    
    //stopAllWheelsPower();
    
    return ;
  }
  

  private void initializeRobot() {
    
      // Initialize the vuforia first, so the camera stream is visible
      initializeCamera();

      //hardware maps of drive motors
      driveBR = hardwareMap.get(DcMotorEx.class, "drive1");
      driveFR = hardwareMap.get(DcMotorEx.class, "drive2");
      driveFL = hardwareMap.get(DcMotorEx.class, "drive3");
      driveBL = hardwareMap.get(DcMotorEx.class, "drive4");
      
      // hardware map for shooter, intake and conveyor 
      shooter1 = hardwareMap.dcMotor.get("shooter1");
      shooter2 = hardwareMap.dcMotor.get("shooter2");
      conveyor = hardwareMap.dcMotor.get("intake");
      noodle = hardwareMap.get(CRServo.class, "intakemotor");
      liftgate = hardwareMap.servo.get("liftgate");
      
      // hardware map for wobble/waffle 
      wafflemotor = hardwareMap.dcMotor.get("wafflemotor");
      waffle1 = hardwareMap.servo.get("waffle1");
      waffle2 = hardwareMap.servo.get("waffle2");
      
      // hardware map for sensors 
      launchLineLeft = hardwareMap.get(ColorSensor.class, "colorLeft");
      launchLineRight = hardwareMap.get(ColorSensor.class, "colorRight");
      distanceLeft = hardwareMap.get(DistanceSensor.class, "distanceLeft");
      distanceFront = hardwareMap.get(DistanceSensor.class, "distanceFront" );
      distanceRight = hardwareMap.get(DistanceSensor.class, "distanceRight" );
      distanceBack = hardwareMap.get(DistanceSensor.class, "distanceBack");
      
      //directions for the differnet motors 
      driveBR.setDirection(DcMotor.Direction.REVERSE);
      driveFR.setDirection(DcMotor.Direction.REVERSE);
      driveBL.setDirection(DcMotor.Direction.FORWARD);
      driveFL.setDirection(DcMotor.Direction.FORWARD);
      
      conveyor.setDirection(DcMotor.Direction.FORWARD); 
      noodle.setDirection(CRServo.Direction.FORWARD);
      
      shooter1.setDirection(DcMotor.Direction.FORWARD);
      shooter2.setDirection(DcMotor.Direction.REVERSE);
      wafflemotor.setDirection(DcMotor.Direction.FORWARD);

      // initial position of the servos 
      // Note that this will cause the waffle goal grabbers to close 
      // and will start consuming power
      
      //wafflemotor.setPower(-1);
      //sleep(1500);
      //wafflemotor.setPower(0);
      
      //sleep(5000);
      
      waffle1.setPosition(1);
      waffle2.setPosition(-1);
      //liftgate.setPosition(1);

      //zero power behavior of the different motors
      driveBL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      driveFL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      driveBR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      driveFR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

      // set the mode of operation; assumes that the encoder wires are connected
      driveBL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      driveFL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      driveBR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      driveFR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

      initializeIMU();
      
      telemetry.addData("Status", "Initialized");
      telemetry.update();

  }
  
  private void initializeCamera() {
    
    vuforiaUltimateGoal = new VuforiaCurrentGame();
    tfodUltimateGoal = new TfodCurrentGame();

    // Sample TFOD Op Mode
    // Initialize Vuforia.
    vuforiaUltimateGoal.initialize(
        "", // vuforiaLicenseKey
        hardwareMap.get(WebcamName.class, "Webcam 1"), // cameraName
        "", // webcamCalibrationFilename
        false, // useExtendedTracking
        false, // enableCameraMonitoring
        VuforiaLocalizer.Parameters.CameraMonitorFeedback.AXES, // cameraMonitorFeedback
        0, // dx
        0, // dy
        0, // dz
        0, // xAngle
        0, // yAngle
        0, // zAngle
        true); // useCompetitionFieldTargetLocations

    // Set min confidence threshold to 0.7; VL: maybe higher confidence??
    tfodUltimateGoal.initialize(vuforiaUltimateGoal, 0.7F, true, true);

    // Initialize TFOD before waitForStart.
    // Init TFOD here so the object detection labels are visible
    // in the Camera Stream preview window on the Driver Station.
    tfodUltimateGoal.activate();

    // Enable following block to zoom in on target.
    // IMPORTANT: Camera zoom and view area are important parameters 
    tfodUltimateGoal.setZoom(2.5, 16 / 9);
    
  }
  
  private void initializeIMU() {
    BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();

    parameters.mode                = BNO055IMU.SensorMode.IMU;
    parameters.angleUnit           = BNO055IMU.AngleUnit.DEGREES;
    parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;
    parameters.loggingEnabled      = false;    

    // get and initialize the IMU 
    // The imu is assumed to be on I2C port 
    // and configured to be a sensor of type "AdaFruit IMU" and named "imu"
    imu = hardwareMap.get(BNO055IMU.class, "imu");

    imu.initialize(parameters);

    telemetry.addData("Mode", "IMU calibrating...");
    telemetry.update();

    // make sure the imu gyro is calibrated before continuing.
    while (!isStopRequested() && !imu.isGyroCalibrated())
    {
      sleep(50);
      idle();
    }

    telemetry.addData("imu calib status", imu.getCalibrationStatus().toString());
    telemetry.update( );
  }
  
  
  private void displayOrientationValues(Orientation orient, String name) {
    telemetry.addData(name, "X: " + orient.firstAngle + ", Y: " + orient.secondAngle + ", Z: " + orient.thirdAngle);
  }
  
  private void resetAngle() {
    lastAngles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);

    globalAngle = 0;
  }

  private double getAngle() {
        
    Orientation angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);

    double deltaAngle = angles.firstAngle - lastAngles.firstAngle;

    if (deltaAngle < -180)
        deltaAngle += 360;
    else if (deltaAngle > 180)
        deltaAngle -= 360;

    globalAngle += deltaAngle;

    lastAngles = angles;

    return globalAngle;
  }

    
  private double checkDirection() {
        
    double correction, angle, gain = .10;

    angle = getAngle();

    if (angle == 0)
        correction = 0;             // no adjustment.
    else
        correction = -angle;        // reverse sign of angle for correction.

    correction = correction * gain;

    return correction;
  }
    
  private void rotate(int degrees, double power) {
    double  leftPower, rightPower;

    // restart imu movement tracking.
    resetAngle();

    // getAngle() returns + when rotating counter clockwise (left) and - when rotating
    // clockwise (right).

    if (degrees < 0)
    {   // turn right.
        leftPower = power;
        rightPower = -power;
    }
    else if (degrees > 0)
    {   // turn left.
        leftPower = -power;
        rightPower = power;
    }
    else return;

    // set power to rotate.
    driveFL.setPower(leftPower);
    driveBL.setPower(leftPower);
    driveFR.setPower(rightPower);
    driveBR.setPower(rightPower);
    
    // rotate until turn is completed.
    if (degrees < 0)
    {
        // On right turn we have to get off zero first.
        while (getAngle() == 0) {}

        while (getAngle() > degrees) {}
    }
    else    // left turn.
        while (getAngle() < degrees) {}

    // turn the motors off.
    stopAllWheelsPower();
    

    // reset angle tracking on new heading.
    resetAngle();
  }


  private void detectZone() {
    // Sometimes Vuforia does not detect well on first go. 
    // we may need to do a couple of tries to be really confident of the 
    // response from the video detection. 
    // For each attempt the robot moves closer to the rings a little bit
    
    int nvideo_attempts = 9; // change this if required. You can change it to 1 as well
    int azone_successes = 0 ;
    float azone_confidence = 0.0F ;
    int bzone_successes = 0 ;
    float bzone_confidence = 0.0F ;
    int czone_successes = 0 ;
    float czone_confidence = 0.0F ;

    List<Recognition> recognitions;
    int index = 0; 

    // get the robot moving and during movement it can check the detection  
    // a number of times 
    moveBackwardPower(0.5);
    
    while (nvideo_attempts > 0) {
      nvideo_attempts-- ; // reduce count first so you dont forget later 
      
      // Put loop blocks here.
      // Get a list of recognitions from TFOD.
      recognitions = tfodUltimateGoal.getRecognitions();

      // If list is empty, inform the user. Otherwise, go
      // through list and display info for each recognition.
      if (recognitions.size() == 0) {
        azone_successes++ ; 
        azone_confidence += 0.9F ; // just giving it something nominal rather than 1.0 
        telemetry.addData("TFOD ", "No items detected.");
        telemetry.addData("Target Zone ", "A");
      } else {
        if (recognitions.size() > 1) {
          telemetry.addData("TFOD ", "More than 1 item detected");
        }
        
        index = 0;
        // Iterate through list and call a function to
        // display info for each recognized object.
        for (Recognition recognition : recognitions) {

          if (recognition.getLabel().equals("Single")) {
            telemetry.addData("Target Zone ", "B");
            bzone_successes++ ; 
            bzone_confidence += recognition.getConfidence() ;
          } else if (recognition.getLabel().equals("Quad")) {
            telemetry.addData("Target Zone ", "C");
            czone_successes++ ; 
            czone_confidence += recognition.getConfidence() ;
          } else {
            telemetry.addData("TFOD ", "Unknown label " + recognition.getLabel());
            telemetry.addData("Target Zone ", "Unknown");
          }
          // Display info.
          //displayInfo(index); Commenting this out because details are not required
          // Increment index.
          index = index + 1;
        } // end of recoginition list 
      } // end of else for recognition list empty
      telemetry.update() ; // make sure telemetry is updated 
      
      // since it is moving anyways 
      sleep(200);
    } // end of while number of tries 
    
    stopAllWheelsPower();

    
    telemetry.addData("AZone ", azone_successes + " " + azone_confidence);
    telemetry.addData("BZone ", bzone_successes + " " + bzone_confidence);
    telemetry.addData("CZone ", czone_successes + " " + czone_confidence);
    
    // Now decide on the final zone 
    // This can be done in a number of ways 
    // simple way would be to use the accumulated confidence levels 
    if (azone_confidence > bzone_confidence) {
      if (azone_confidence > czone_confidence) {
        // A is the clear winner
        final_zone = AZONE ; 
        telemetry.addData("Final Zone", " A");
      } else {
        // C is the clear winner
        final_zone = CZONE ;
        telemetry.addData("Final Zone", " C");
      }
    } else {
      if (bzone_confidence > czone_confidence){
        // B is the clear winner 
        final_zone = BZONE ;
        telemetry.addData("Final Zone", " B");
      } else {
        // C is the winner
        final_zone = CZONE ;
        telemetry.addData("Final Zone", " C");
      }
    }
    telemetry.update(); 
    
    // by the end of this routine, final_zone carries the zone value 
  }
  
  private void moveForwardPower(double power) {
    driveBL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setPower(power);
    driveFR.setPower(power);
    driveBL.setPower(power);
    driveFL.setPower(power);
  }
  
  private void moveForwardVelocity(double nticks) {
    driveBL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBL.setVelocity(nticks) ;
    driveFL.setVelocity(nticks) ;
    driveBR.setVelocity(nticks) ;
    driveFR.setVelocity(nticks) ;
  }


  private void moveBackwardPower(double power) {
    driveBL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setPower(power * -1.0);
    driveFR.setPower(power * -1.0);
    driveBL.setPower(power * -1.0);
    driveFL.setPower(power * -1.0);
  }

  private void moveBackwardVelocity(double nticks) {
    driveBL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBL.setVelocity(nticks * -1.0) ;
    driveFL.setVelocity(nticks * -1.0) ;
    driveBR.setVelocity(nticks * -1.0) ;
    driveFR.setVelocity(nticks * -1.0) ;
  }
  
  private void moveForwardIMU(double power) {
    
    correction = checkDirection();

    driveBL.setPower(power - correction);
    driveFL.setPower(power - correction);
    driveBR.setPower(power + correction);
    driveFR.setPower(power + correction);

  }
  
  private void moveBackwardIMU(double power) {
    
    correction = checkDirection();

    driveBL.setPower((power - correction) * -1.0);
    driveFL.setPower((power - correction) * -1.0);
    driveBR.setPower((power + correction) * -1);
    driveFR.setPower((power + correction) * -1);

  }
  
  private void strafeRightIMU(double power) {
    
    correction = checkDirection();

    driveBL.setPower((power - correction));
    driveFL.setPower((power - correction) * -1.0);
    driveBR.setPower((power + correction) * -1);
    driveFR.setPower((power + correction));

  }

  private void strafeRightPower(double power) {
    driveBL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setPower(power * -1.0);
    driveFR.setPower(power);
    driveBL.setPower(power);
    driveFL.setPower(power * -1.0);
  }
  
  private void strafeRightVelocity(double nticks) {
    driveBL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBR.setVelocity(nticks * -1.0) ;
    driveFR.setVelocity(nticks) ;
    driveBL.setVelocity(nticks) ;
    driveFL.setVelocity(nticks * -1.0) ;
  }
  
  private void strafeLeftPower(double power) {
    driveBL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    driveBR.setPower(power);
    driveFR.setPower(power * -1.0);
    driveBL.setPower(power * -1.0);
    driveFL.setPower(power);
  }

  private void strafeLeftVelocity(double nticks) {
    driveBL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveFR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    driveBR.setVelocity(nticks) ;
    driveFR.setVelocity(nticks * -1.0) ;
    driveBL.setVelocity(nticks * -1.0) ;
    driveFL.setVelocity(nticks) ;
  }
  
  
  
  private void moveBackwardAlongPerimeterToLaunchLineAndAlign(double plevel) {
    
    double target_distance = 15.0; // 2 parameters for tuning 
    double max_deviation = 4.0 ;   // Change these two parameters for alignment 
    double cur_distance = 0.0;
    double abs_distance;
    double power_correction = 0.0;
    
    int minWhiteColorAlpha = 1000 ; // Another parameter to tune 
    int colorRight = 0;
    int colorLeft = 0;
    
    // first just make the plevel negative
    moveBackwardPower(plevel);    
    
    colorRight = launchLineRight.alpha() ;
    colorLeft = launchLineLeft.alpha() ;
    // Do the while loop until a certain time is reached 
    while ((colorRight < minWhiteColorAlpha) && (colorLeft < minWhiteColorAlpha)) {
      
      cur_distance = distanceRight.getDistance(DistanceUnit.INCH); 
      abs_distance = Math.abs(cur_distance - target_distance);
      
      if (abs_distance >= max_deviation) {
        
        if (cur_distance >= (target_distance + max_deviation)) {
          strafeRightPower(1.0) ;
          while(distanceRight.getDistance(DistanceUnit.INCH) > target_distance) {
          }
          moveBackwardPower(plevel) ;
        } else {
          if (cur_distance <= (target_distance - max_deviation)) {
            strafeLeftPower(1.0) ;
            while(distanceRight.getDistance(DistanceUnit.INCH) < target_distance) {
            }
            moveBackwardPower(plevel) ;
          } else {
            // it should not come here 
            moveBackwardPower(plevel) ;
            // Look at exception handling later ; for now just use telemetry 
            telemetry.addData("Exception", "Error in target distance") ;
            telemetry.update() ;
            //throw new Exception("Error in target distance") ;
            // Exception requires try and catch blocks 
          }
        }
      }

      /*      
      // A different strategy; but not working well
      if (abs_distance > 2.0) {
        
        power_correction = 0.5*plevel;
        
      } else {
        
        power_correction = plevel*(1.0-(0.5*(abs_distance/2.0)));
        //power_correction = plevel*(1.0-(abs_distance/2.0));
      }
      if (cur_distance > target_distance) {
        
        driveFL.setPower(plevel);
        driveBL.setPower(plevel);
        driveFR.setPower(power_correction); // slow down the right side 
        driveBR.setPower(power_correction);
        
      } else {
        
        driveFL.setPower(power_correction); // slow down the left side 
        driveBL.setPower(power_correction);
        driveFR.setPower(plevel);
        driveBR.setPower(plevel);
        
      }
      */
      colorRight = launchLineRight.alpha() ;
      colorLeft = launchLineLeft.alpha() ;
      
    }
    //stopAllWheelsPower();
    //telemetry.addData("Color sensor First","Right: " + colorRight + " Left: " + colorLeft) ;
    //telemetry.addData("Color sensor Second","Right: " + launchLineRight.alpha() + " Left: " + launchLineLeft.alpha()) ;
    //telemetry.update();
    //sleep(1000);
    
    // Now align it to the LaunchLine using the two color sensors 
    if ((colorRight >= minWhiteColorAlpha) && (colorLeft >= minWhiteColorAlpha)) {
        // dont need to do anything 
    } else {
      if ((colorRight < minWhiteColorAlpha) && (colorLeft >= minWhiteColorAlpha)) {
        // move the right wheels 
        // Note that we are moving backward 
        // May need to go a bit slower rather than full speed
        driveFR.setPower(plevel * -1.0);
        driveBR.setPower(plevel * -1.0);
        driveFL.setPower(0.0);
        driveBL.setPower(0.0);
        // Note that the left wheels are stationary 
        while (launchLineRight.alpha() < minWhiteColorAlpha) {
          // it might be required to move both 
          // How about getting rightColor closer to leftColor 
          // Will it be any better? 
          ;
        }
        stopAllWheelsPower();
      } else {
        if ((colorRight >= minWhiteColorAlpha) && (colorLeft < minWhiteColorAlpha)) {
          // move the left wheels 
          driveFL.setPower(plevel * -1.0);
          driveBL.setPower(plevel * -1.0);
          driveFR.setPower(0.0);
          driveBR.setPower(0.0);
          while (launchLineLeft.alpha() < minWhiteColorAlpha) {
            // it might be required to move both 
            // How about getting rightColor closer to leftColor 
            // Will it be any better? 
            ;
          }
          stopAllWheelsPower();
        } else {
          // this means that neither of the two sensors are on the whiteline
          // Ideally, it should not come here. 
          // If it does, throw an exception 
          // Look at exception handling later ; for now just use telemetry 
          telemetry.addData("Exception", "Both color sensors shows less than minWhiteColorAlpha 1") ;
          telemetry.update() ;
          //throw new Exception("Both color sensors shows less than minWhiteColorAlpha") ;
          // Exception requires try and catch blocks 
        }
      }
    }
    stopAllWheelsPower();
  }


  private void moveBackwardToLaunchLineAndAlign(double plevel) {
    
    int minWhiteColorAlpha = 1000 ; // Another parameter to tune 
    int colorRight = 0;
    int colorLeft = 0;
    
    int colorRightAfterBreak ;
    
    // start moving back 
    moveBackwardPower(plevel);    
    
    // Do the while loop until the color is reached
    colorRight = launchLineRight.alpha() ;
    colorLeft = launchLineLeft.alpha() ;
    while ((colorRight < minWhiteColorAlpha) && (colorLeft < minWhiteColorAlpha)) {
      colorRight = launchLineRight.alpha() ;
      colorLeft = launchLineLeft.alpha() ;
    }
    //stopAllWheelsPower();
    //sleep(2000);
    //telemetry.addData("Color sensor First","Right: " + colorRight + " Left: " + colorLeft) ;
    //telemetry.addData("Color sensor Second","Right: " + launchLineRight.alpha() + " Left: " + launchLineLeft.alpha()) ;
    //telemetry.update();
    //sleep(1000);
    
    // check if the braking action caused some changes 
    
    
    // Now align it to the LaunchLine using the two color sensors 
    if ((colorRight >= minWhiteColorAlpha) && (colorLeft >= minWhiteColorAlpha)) {
        // dont need to do anything 
    } else {
      if ((colorRight < minWhiteColorAlpha) && (colorLeft >= minWhiteColorAlpha)) {
        // move the right wheels 
        // Note that we are moving backward 
        // May need to go a bit slower rather than full speed
        driveFR.setPower(plevel * -1.0);
        driveBR.setPower(plevel * -1.0);
        driveFL.setPower(0.0);
        driveBL.setPower(0.0);
        // Note that the left wheels are stationary 
        while (launchLineRight.alpha() < minWhiteColorAlpha) {
          // it might be required to move both 
          // How about getting rightColor closer to leftColor 
          // Will it be any better? 
          ;
        }
        stopAllWheelsPower();
      } else {
        if ((colorRight >= minWhiteColorAlpha) && (colorLeft < minWhiteColorAlpha)) {
          // move the left wheels 
          driveFL.setPower(plevel * -1.0);
          driveBL.setPower(plevel * -1.0);
          driveFR.setPower(0.0);
          driveBR.setPower(0.0);
          while (launchLineLeft.alpha() < minWhiteColorAlpha) {
            // it might be required to move both 
            // How about getting rightColor closer to leftColor 
            // Will it be any better? 
            ;
          }
          stopAllWheelsPower();
        } else {
          // this means that neither of the two sensors are on the whiteline
          // Ideally, it should not come here. 
          // If it does, throw an exception 
          // Look at exception handling later ; for now just use telemetry 
          telemetry.addData("Exception", "Both color sensors shows less than minWhiteColorAlpha 2") ;
          telemetry.update() ;
          //throw new Exception("Both color sensors shows less than minWhiteColorAlpha") ;
          // Exception requires try and catch blocks 
        }
      }
    }
    stopAllWheelsPower();
  }

  // do we have to set the mode when switching off?  
  public boolean shouldStop() {
    return (distanceRight.getDistance(DistanceUnit.INCH) > 7);
  }
      
  private void stopAllWheelsPower() {
    driveBL.setPower(0.0);
    driveFL.setPower(0.0);
    driveBR.setPower(0.0);
    driveFR.setPower(0.0);
  }

  private void runShooter(double power) {

      shooter1.setPower(power);
      shooter2.setPower(power);

  }
  
  private void stopShooter() {

      shooter1.setPower(0.0);
      shooter2.setPower(0.0);

  }

  private void runInclinedPlane(double power) {
      conveyor.setPower(power);
  }
  
  private void stopInclinedPlane() {
      conveyor.setPower(0.0);
  }

  private void runNoodleIntake(double power) {
      noodle.setPower(power);
  }
  
  private void stopNoodleIntake() {
      noodle.setPower(0.0);
  }
  
  private void dropWaffleGoal() {
    
      // lower the waffle motor and then stop it 
      wafflemotor.setPower(1);
      sleep(1500);
      wafflemotor.setPower(0);
      
      // Open the grips 
      waffle1.setPosition(-1);
      waffle2.setPosition(1);
      

  }
  

  private void targetZoneA() {
    
    // drop the wobble goal.
    dropWaffleGoal();
    
    // strafe left to clear off the waffle 
    strafeLeftPower(1.0) ;
    sleep(500) ;
    stopAllWheelsPower();
    
    // turn 180 degrees 
    rotate(180,1.0) ;
    
    // make sure that the robot is back on the white line 
    moveBackwardToLaunchLineAndAlign(0.75) ;

  }

  private void targetZoneB() {

    // moveBackward for 2 seconds 
    moveBackwardPower(0.75) ;
    sleep(1500) ;
    stopAllWheelsPower();
    
    // strafe left for 2 seconds 
    strafeLeftPower(1.0) ;
    sleep(2500) ;
    stopAllWheelsPower();
    // drop the wabble goal 
    dropWaffleGoal();
    // strafe left to clear off the waffle 
    strafeLeftPower(1.0) ;
    sleep(500) ;
    stopAllWheelsPower();
    
    // turn 180 degrees 
    // Better to turn now rather than later 
    rotate(180,0.75) ;
    
    // move back to the LaunchLine and align 
    // dont use distance sensor this time 
    moveBackwardToLaunchLineAndAlign(0.75) ;
    
  }

  private void targetZoneC() {
    
    // moveBackward until distanceBack is less than 10 inches  
    moveBackwardPower(0.75) ;
    while (distanceBack.getDistance(DistanceUnit.INCH) > 10) {
      // it might be off so adjust if required 
      // may want to check for blue line 
      ; 
    }
    stopAllWheelsPower();
    
    strafeLeftPower(1.0) ;
    sleep(1250);
    stopAllWheelsPower();
    
    
    // drop the wabble goal 
    dropWaffleGoal();
    // strafe left to clear off the waffle 
    strafeLeftPower(1.0) ;
    sleep(500) ;
    stopAllWheelsPower();
    
    // turn 180 degrees 
    // Better to turn now rather than later 
    rotate(180,1.0) ;
    
    // move back to the LaunchLine and align 
    // dont use distance sensor this time 
    moveBackwardToLaunchLineAndAlign(0.75) ;
  }

  private void testRightColorSensorRun() {
    int redval = 0 ;
    int greenval = 0 ;
    int blueval = 0 ; 
    int combval = 0;
    int alphaval = 0 ;
    //double startTime = 0; 
    //double curTime = 0; 
    long startTime = 0; 
    
    //startTime = rtime.milliseconds() ; 
    startTime = System.currentTimeMillis() ; 

    redval = launchLineRight.red() ;
    greenval = launchLineRight.green() ;
    blueval = launchLineRight.blue() ; 
    alphaval = launchLineRight.alpha() ;
    telemetry.addData("Color Sensor Start", "red: " + redval + " green: " + greenval + " blue: " + blueval + " alpha: " + alphaval);

    moveBackwardPower(0.75);    
    
    while ((System.currentTimeMillis() - startTime) < 4000) {
      //telemetry.addData("distanceRight", " " + distanceRight.getDistance(DistanceUnit.INCH) + "in.");
      //telemetry.addData("distanceLeft", " " + distanceLeft.getDistance(DistanceUnit.INCH) + "in.");
      //telemetry.addData("distanceBack", " " + distanceBack.getDistance(DistanceUnit.INCH) + "in.");
      int tempredval = launchLineRight.red() ;
      int tempgreenval = launchLineRight.green() ;
      int tempblueval = launchLineRight.blue() ;
      int tempalphaval = launchLineRight.alpha() ;
      int tempval = tempredval + tempgreenval + tempblueval ; 
      if (tempval > combval) {
        redval = tempredval ; 
        greenval = tempgreenval ; 
        blueval = tempblueval ; 
        alphaval = tempalphaval ; 
        combval = tempval ; 
        
      }
      /*
      if (tempalphaval > 1000) {
        redval = tempredval ; 
        greenval = tempgreenval ; 
        blueval = tempblueval ; 
        alphaval = tempalphaval ; 
        combval = tempval ; 
        break ;
      }
      */
    }
    telemetry.addData("Color Sensor End", "red: " + redval + " green: " + greenval + " blue: " + blueval + " alpha: " + alphaval);
    telemetry.update() ;
    stopAllWheelsPower();
    
  }
  
  private void testLeftColorSensorRun() {
    int redval = 0 ;
    int greenval = 0 ;
    int blueval = 0 ; 
    int combval = 0;
    int alphaval = 0 ;
    //double startTime = 0; 
    //double curTime = 0; 
    long startTime = 0; 
    
    //startTime = rtime.milliseconds() ; 
    startTime = System.currentTimeMillis() ; 

    redval = launchLineLeft.red() ;
    greenval = launchLineLeft.green() ;
    blueval = launchLineLeft.blue() ; 
    alphaval = launchLineLeft.alpha() ;
    telemetry.addData("Color Sensor Start", "red: " + redval + " green: " + greenval + " blue: " + blueval + " alpha: " + alphaval);

    moveBackwardPower(0.75);    
    
    while ((System.currentTimeMillis() - startTime) < 4000) {
      //telemetry.addData("distanceRight", " " + distanceRight.getDistance(DistanceUnit.INCH) + "in.");
      //telemetry.addData("distanceLeft", " " + distanceLeft.getDistance(DistanceUnit.INCH) + "in.");
      //telemetry.addData("distanceBack", " " + distanceBack.getDistance(DistanceUnit.INCH) + "in.");
      int tempredval = launchLineRight.red() ;
      int tempgreenval = launchLineRight.green() ;
      int tempblueval = launchLineRight.blue() ;
      int tempalphaval = launchLineRight.alpha() ;
      int tempval = tempredval + tempgreenval + tempblueval ; 
      if (tempval > combval) {
        redval = tempredval ; 
        greenval = tempgreenval ; 
        blueval = tempblueval ; 
        alphaval = tempalphaval ; 
        combval = tempval ; 
        
      }
      /*
      if (tempalphaval > 1000) {
        redval = tempredval ; 
        greenval = tempgreenval ; 
        blueval = tempblueval ; 
        alphaval = tempalphaval ; 
        combval = tempval ; 
        break ;
      }
      */
    }
    telemetry.addData("Color Sensor End", "red: " + redval + " green: " + greenval + " blue: " + blueval + " alpha: " + alphaval);
    telemetry.update() ;
    stopAllWheelsPower();
    
  }
  
  private void testStrafing(double plevel) {
    strafeRightPower(1.0) ;
    sleep(3000);
    stopAllWheelsPower();
    sleep(1000);
    
    strafeLeftPower(1.0) ;
    sleep(3000);
    stopAllWheelsPower();
    sleep(1000);
  }
  
  private void shootPowerShots() {
    
    runShooter(1);
    sleep(3000);
    
    runInclinedPlane(1);
    
    
  }

} // end of VLTestAutonomous ClassNotFoundException

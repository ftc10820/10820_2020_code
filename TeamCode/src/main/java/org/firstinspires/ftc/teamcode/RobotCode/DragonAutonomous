package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import java.util.List;
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaCurrentGame;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
import org.firstinspires.ftc.robotcore.external.tfod.Recognition;
import org.firstinspires.ftc.robotcore.external.tfod.TfodCurrentGame;

@Autonomous
public class DragonAutonomous extends LinearOpMode {

  private VuforiaCurrentGame vuforiaUltimateGoal;
  private TfodCurrentGame tfodUltimateGoal;
  private DcMotor drive1;
  private DcMotor drive2;
  private DcMotor drive3;
  private DcMotor drive4;
  private DcMotor shooter1;
  private DcMotor shooter2;
  private DcMotor intake;
  private DcMotor wafflemotor;

  
  private CRServo intakemotor;
  private Servo waffle1;
  private Servo waffle2;

  private ColorSensor launchLine;



  Recognition recognition;

  /**
   * This function is executed when this Op Mode is selected from the Driver Station.
   */
  @Override
  public void runOpMode() {
    
    initializeRobot();
    
    List<Recognition> recognitions;
    double index;

    vuforiaUltimateGoal = new VuforiaCurrentGame();
    tfodUltimateGoal = new TfodCurrentGame();

    // Sample TFOD Op Mode
    // Initialize Vuforia.
    vuforiaUltimateGoal.initialize(
        "", // vuforiaLicenseKey
        hardwareMap.get(WebcamName.class, "Webcam 1"), // cameraName
        "", // webcamCalibrationFilename
        false, // useExtendedTracking
        false, // enableCameraMonitoring
        VuforiaLocalizer.Parameters.CameraMonitorFeedback.AXES, // cameraMonitorFeedback
        0, // dx
        0, // dy
        0, // dz
        0, // xAngle
        0, // yAngle
        0, // zAngle
        true); // useCompetitionFieldTargetLocations
    
    // Set min confidence threshold to 0.7
    tfodUltimateGoal.initialize(vuforiaUltimateGoal, 0.7F, true, true);
    
    // Initialize TFOD before waitForStart.
    // Init TFOD here so the object detection labels are visible
    // in the Camera Stream preview window on the Driver Station.
    tfodUltimateGoal.activate();
    
    // Enable following block to zoom in on target.
    tfodUltimateGoal.setZoom(2.5, 16 / 9);
    telemetry.addData(">", "Press Play to start");
    telemetry.update();
    
    // Wait for start command from Driver Station.
    
    waitForStart();
    
    if (opModeIsActive()) {
    
      while (launchLine.alpha() < 275) {
          
        drive1.setPower(0.5);
        drive2.setPower(0.5);
        drive3.setPower(0.5);
        drive4.setPower(0.5);
      
      }
      
      drive1.setPower(-0.5);
      drive2.setPower(-0.5);
      drive3.setPower(-0.5);
      drive4.setPower(-0.5);
      sleep(100);
      
      drive1.setPower(0);
      drive2.setPower(0);
      drive3.setPower(0);
      drive4.setPower(0);
      
      shooter(0.75);
      sleep(2000);
      
      inclinedPlane(1);
      sleep(2000);
      
      noodles(1);
      sleep(10000);
    
      shooter(0);
      inclinedPlane(0);
      noodles(0);
    
    
      while (opModeIsActive()) {
        // Put loop blocks here.
        // Get a list of recognitions from TFOD.
        recognitions = tfodUltimateGoal.getRecognitions();
        
        // If list is empty, inform the user. Otherwise, go
        // through list and display info for each recognition.
        if (recognitions.size() == 0) {
          telemetry.addData("TFOD", "No items detected.");
          telemetry.addData("Target Zone", "A");
        } else {
          index = 0;
          
          // Iterate through list and call a function to
          // display info for each recognized object.
          for (Recognition recognition_item : recognitions) {
            recognition = recognition_item;
            // Display info.
            displayInfo(index);
            // Increment index.
            index = index + 1;
          }
        }
        
        telemetry.addData("red:", launchLine.red());
        telemetry.addData("blue:", launchLine.blue());
        telemetry.addData("green:", launchLine.green());
          telemetry.addData("alpha:", launchLine.alpha());
        
        telemetry.update();
      }
      
      
   
      
      
    }
    // Deactivate TFOD.
    tfodUltimateGoal.deactivate();

    vuforiaUltimateGoal.close();
    tfodUltimateGoal.close();
  }
  
  
  /**
   * Display info (using telemetry) for a recognized object.
   */
  private void displayInfo(double i) {
    // Display label info.
    // Display the label and index number for the recognition.
    telemetry.addData("label " + i, recognition.getLabel());
    // Display upper corner info.
    // Display the location of the top left corner
    // of the detection boundary for the recognition
    telemetry.addData("Left, Top " + i, recognition.getLeft() + ", " + recognition.getTop());
    // Display lower corner info.
    // Display the location of the bottom right corner
    // of the detection boundary for the recognition
    telemetry.addData("Right, Bottom " + i, recognition.getRight() + ", " + recognition.getBottom());
    
    if (recognition.getLabel().equals("Single")) {
      
      telemetry.addData("Target Zone", "B");
      
    } else if (recognition.getLabel().equals("Quad")) {
      
      telemetry.addData("Target Zone", "C");
      
    } else {
      
      telemetry.addData("Target Zone", "UNKNOWN");
      
    }
  }
  
    
    private void initializeRobot() {
    
        //hardware maps of motors
        drive1 = hardwareMap.dcMotor.get("drive1");
        drive2 = hardwareMap.dcMotor.get("drive2");
        drive3 = hardwareMap.dcMotor.get("drive3");
        drive4 = hardwareMap.dcMotor.get("drive4");
        intake = hardwareMap.dcMotor.get("intake");
        shooter1 = hardwareMap.dcMotor.get("shooter1");
        shooter2 = hardwareMap.dcMotor.get("shooter2");
        wafflemotor = hardwareMap.dcMotor.get("wafflemotor");
        intakemotor = hardwareMap.get(CRServo.class, "intakemotor");
        launchLine = hardwareMap.get(ColorSensor.class, "color");

    
        //hardware maps of servos

        waffle1 = hardwareMap.servo.get("waffle1");
        waffle2 = hardwareMap.servo.get("waffle2");
    
        //directions
        drive1.setDirection(DcMotor.Direction.REVERSE);
        drive2.setDirection(DcMotor.Direction.REVERSE);
        drive3.setDirection(DcMotor.Direction.FORWARD);
        drive4.setDirection(DcMotor.Direction.FORWARD);
        intake.setDirection(DcMotor.Direction.FORWARD);
        shooter1.setDirection(DcMotor.Direction.FORWARD);
        shooter2.setDirection(DcMotor.Direction.REVERSE);
        wafflemotor.setDirection(DcMotor.Direction.FORWARD);
        intakemotor.setDirection(CRServo.Direction.FORWARD);
        
        //zero power behavior
        drive1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        drive2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        drive3.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        drive4.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);


        
        telemetry.addData("Status", "Initialized");
        telemetry.update();

    }
    
    private void moveForward(double power, long time) {
      
      drive1.setPower(power);
      drive2.setPower(power);
      drive3.setPower(power);
      drive4.setPower(power);
      sleep(time);
      
    }
    
    private void moveBackward(double power, long time) {
      
      drive1.setPower(power * -1.0);
      drive2.setPower(power * -1.0);
      drive3.setPower(power * -1.0);
      drive4.setPower(power * -1.0);
      sleep(time);
      
    }
    
    private void shooter(double power) {
        
        shooter1.setPower(power * -1.0);
        shooter2.setPower(power);
        
    }
    
    private void inclinedPlane(double power) {
        
        intake.setPower(power);
        
        
    }
    
    private void noodles(double power) {
        
        intakemotor.setPower(power);
        
        
    }
    
    private void targetZoneA() {
        
        moveForward(1, 1000);
        
        
        
    }
    
    private void targetZoneB() {
        
        moveForward(1, 1000);
        
        
        
    }
    
    private void targetZoneC() {
        
        moveForward(1, 1000);
        
        
        
    }
    
    private void starterStackDetection() {
        
        if (recognition.getLabel().equals("Single")) {
      
            telemetry.addData("Target Zone", "B");
            
            
      
        } else if (recognition.getLabel().equals("Quad")) {
      
            telemetry.addData("Target Zone", "C");
      
        } else {
      
            telemetry.addData("Target Zone", "A");
      
            }
        
    }
    
    
}
    
    
    
